[{"id":0,"href":"/nijigp/docs/functionality/polygon/","title":"- Polygons -","section":"Functionality","content":""},{"id":1,"href":"/nijigp/docs/developer_notes/algorithms/","title":"Algorithm Design","section":"Developer Notes","content":"\rAlgorithm Design\r#\rThis page provides an in-depth exploration of the algorithms utilized by this add-on, both for developers interested in vector graphics processing and for users wondering about the core principles underlying the add-on’s functionality.\nIt is less recommended to read the source code directly, since the code details are not excellent and still need refinement. Instead, this article focuses more on the mathematics behind each feature.\nThe add-on’s functions fall into two categories:\nThe first category comprises classical algorithms and I simply deploy third-party Python packages to perform them. For these functions, this page lists the names of the packages and the main algorithms for reference. The second category consists of methods developed by myself learning mainly from academic projects. The documentation describes the main steps of each method and the research papers I used as inspiration. Since this is not a formal academic publication, for some well-known concepts I will cite Wikipedia pages as the source for convenience.\rPolygon Operations\r#\rThe polygon operations (Boolean, offset and sweep) are performed by directly adopting the Clipper library without my own design. Several classic algorithms are implemented in Clipper:\nBoolean operations are achieved by the Vatti clipping algorithm[1]. Hole detection and offset are achieved by computing winding numbers[2]. Sweep operation is achieved by using Minkowski addition[3]. Vatti, Bala R. \u0026quot;A generic solution to polygon clipping.\u0026quot; Communications of the ACM 35, no. 7 (1992): 56-63. Chen, Xiaorui, and Sara McMains. \u0026quot;Polygon offsetting by computing winding numbers.\u0026quot; In International Design Engineering Technical Conferences and Computers and Information in Engineering Conference, vol. 4739, pp. 565-575. 2005. https://en.wikipedia.org/wiki/Minkowski_addition Sketch Cleanup\r#\rThe purpose of sketch cleanup is to merge multiple 2D strokes with the similar shape into a single, smooth one. It looks like a curve fitting problem, but it is not trivial to solve:\nIt is common that the input strokes cannot be represented by a function \\(y=f(x)\\)\rsince a single \\(x\\)\rmay correspond to multiple \\(y\\)\rvalues. Modeling input strokes as is also problematic, because it is hard to determine the parameter \\(t\\)\r(i.e., the order of input points) among multiple input strokes. The method adopted here is to treat the input strokes as a set of unordered 2D points and then construct a curve from them. I refer to two research papers[1][2] which share several common steps:\nPerform Delaunay triangulation[3] on all input points and treat the result as a graph. Calculate the minimum spanning tree (MST)[4] of this graph. Find the longest path between any two nodes in MST. These steps lead to a 2D path which is the output stroke, but it is usually not smooth enough. The two research papers have different ways further processing the stroke. Considering the time complexity, however, a distinct method is developed for this add-on:\nFor each point in the calculated longest path, find other input points (that do not belong to the path) in the neighborhood given a radius value. Average their coordinate of the normal direction. Perform a B-spline fitting using SciPy to get the final result. Multiple input strokes to fit.\rTriangulation from the input point set.\rGet MST from the triangles.\rGet the longest path from MST.\rSmooth the longest path to get the final result.\rLee, In-Kwon. \u0026quot;Curve reconstruction from unorganized points.\u0026quot; Computer aided geometric design 17, no. 2 (2000): 161-177. Liu, Chenxi, Enrique Rosales, and Alla Sheffer. \u0026quot;Strokeaggregator: Consolidating raw sketches into artist-intended curve drawings.\u0026quot; ACM Transactions on Graphics (TOG) 37, no. 4 (2018): 1-15. https://en.wikipedia.org/wiki/Delaunay_triangulation https://en.wikipedia.org/wiki/Minimum_spanning_tree Smart Fill\r#\rLazyBrush[1] is a tool that allows users to fill a line art based on some hint colors drawn on it. It is originally designed to process pixels of a raster image. This add-on adopts the concept of LazyBrush, but modifies the algorithm to make it work for vector arts.\nThe key idea is the max-flow min-cut theorem[2]. The min-cut partitions a graph into two disjoint subsets. We use it to partition the points of the line art, and assign a color to each output subset, which is how the line art is filled.\nThe way of constructing a node graph from the vector line art is inspired by the research paper Delaunay Painting[3]. The add-on performs Delaunay triangulation on the line art stroke points, and builds a graph with triangles as graph nodes. For each pair of adjacent triangles (sharing an edge):\nIf the edge belongs to the line art, do not create a link between the two graph nodes. Otherwise, create a weighted link. The weight is the length of the edge. The max-flow min-cut method requires source and sink nodes, which are triangles with two different hint colors. With the min-cut disconnecting source nodes from sink nodes, the graph is partitioned into two, which are the filling areas of these two colors. If there are \\(N\u0026gt;2\\)\rhint colors, just repeat this process for \\(N-1\\)\rtimes.\nThe description above may be obscure since many details of the graph theory have to be involved. The figures below aim at providing an intuitive example about how this method works.\nInput line art and hint strokes.\rDivide the line art into triangles.\rConvert triangles to a node graph.\rPartition the graph into two parts.\rFill each subgraph with one color.\rSýkora, Daniel, John Dingliana, and Steven Collins. \u0026quot;Lazybrush: Flexible painting tool for hand‐drawn cartoons.\u0026quot; In Computer Graphics Forum, vol. 28, no. 2, pp. 599-608. Oxford, UK: Blackwell Publishing Ltd, 2009. https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem Parakkat, Amal Dev, Pooran Memari, and Marie‐Paule Cani. \u0026quot;Delaunay Painting: Perceptual Image Colouring from Raster Contours with Gaps.\u0026quot; In Computer Graphics Forum, vol. 41, no. 6, pp. 166-181. 2022. Mesh Generation\r#\rAmong different mesh generation operators, the Offset/Frustum method uses the same algorithm as the polygon offset, while the normal interpolation method is based on a different principle.\nNormal Vector Interpolation\r#\rThis method aims at generating continuous normal vectors on a 2D surface to create an effect of depth and 2D lighting. Research projects such as Lumo[1] have proposed to adopt this method to create shading for hand-drawn animation.\nThe algorithm starts with a Grease Pencil stroke, which can be seen as the contour of a 2D shape. Supposing the contour contains \\(C\\)\rpoints, \\(\\{(x_1, y_1), (x_2, y_2), ..., (x_C, y_C)\\}\\)\r, it is easy to get their 2D normal vectors \\( \\{(n_{1x}, n_{1y}), (n_{2x}, n_{2y}), ..., (n_{Cx}, n_{Cy})\\} \\)\r. We then normalize them to the unit length and treat them as 3D vectors, assuming that the third dimension has zero value, i.e., assuming the vector is parallel to the 2D work plane.\nCalculated 2D normal vectors from stroke points.\rAdd new vertices inside the stroke shape.\rEach new vertex's normal vector is a weighted average of all contour normal vectors.\rThen we create new vertices inside the shape. To calculate the normal vector of such an inside vertex, we take the weighted average of the normal vectors of all the contour points. The weight is the reciprocal squared distance from this new vertex to a contour point.\nThe equations above give us the first two components of the normal vector. By assuming the unit length, we can get the third component:\nThis distance-based weighting and averaging can result in a smooth appearance. For example, a 2D circle will be shaded like a sphere.\nHeight/Depth Calculation\r#\rA normal map can be converted to height/depth values to get an actual 3D mesh. This add-on implements an inflation method by modifying a pixel-based algorithm[2] to a vector-based one.\nThe method is based on the fact that the normal vector should always be perpendicular to the tangent vector. The tangent vector of a vertex \\(a\\)\rcan be calculated by subtracting its coordinates from those of another vertex \\(b \\in \\Gamma_{a}\\)\rthat shares an edge with it. In this way, an energy function can be defined by summing up the squared production of each pair of normal and tangent vectors, taking each edge in the mesh into account:\nThe closer this energy is to zero, the more realistic the depth values are. Since the derivative of energy is linear, there is a wide range of optimizers available for this problem. The add-on adopts the L-BFGS-B algorithm provided by SciPy.\nAlthough not using its algorithm directly, the mesh generation module is also largely inspired by Monster Mash[3].\n2D Shading\r#\rThis add-on also supports calculating shadows and lights directly as vector polygons instead of generating 3D meshes. Similar concepts have also been discussed in some research papers. Unlike the research[4] which proposes a novel formula to determine the shadow terminator, this add-on simply reuses the same method of normal interpolation combined with Boolean operations. However, my implementation benefits from certain techniques suggested by this research, such as sampling along the direction of the light.\nJohnston, Scott F. \u0026quot;Lumo: illumination for cel animation.\u0026quot; In Proceedings of the 2nd international symposium on Non-photorealistic animation and rendering, pp. 45-ff. 2002. Hudon, Matis, Sebastian Lutz, Rafael Pagés, and Aljosa Smolic. \u0026quot;Augmenting hand-drawn art with global illumination effects through surface inflation.\u0026quot; In Proceedings of the 16th ACM SIGGRAPH European Conference on Visual Media Production, pp. 1-9. 2019. Dvorožňák, Marek, Daniel Sýkora, Cassidy Curtis, Brian Curless, Olga Sorkine-Hornung, and David Salesin. \u0026quot;Monster mash: a single-view approach to casual 3D modeling and animation.\u0026quot; ACM Transactions on Graphics (TOG) 39, no. 6 (2020): 1-12. Hudon, Matis, Rafael Pagés, Mairéad Grogan, Jan Ondřej, and Aljoša Smolić. \u0026quot;2D shading for cel animation.\u0026quot; In Proceedings of the Joint Symposium on Computational Aesthetics and Sketch-Based Interfaces and Modeling and Non-Photorealistic Animation and Rendering, pp. 1-12. 2018. Image Vectorization\r#\rThe image vectorization operators (including line art extraction and color quantization) are mostly performed by directly calling functions of SciPy and Scikit-Image modules.\nLine Art Extraction\r#\rThe algorithm used for extracting lines from raster image pixels belongs to skeletonization or thinning. There have been several famous methods[1,2] developed for this purpose. This add-on chooses medial_axis implemented in skimage.morphology, since it calculates the distance from a pixel to the extracted skeleton, which is later converted to the radius of Grease Pencil stroke points.\nColor Quantization\r#\rTo vectorize a color image, the add-on uses the clustering algorithm to reduce the number of colors of the original image, so that pixels of each color can be treated one by one, just like a black-and-white image. The clustering algorithm in use is a very common one, K-means[3], treating each pixel's rgb values as a 3D vector.\nAfter color reduction, the add-on converts each connected pixel regions to a contour by calling the function find_contours in skimage.measure, which uses the marching squares algorithm[4].\nSkimage Skeletonize, https://scikit-image.org/docs/stable/auto_examples/edges/plot_skeleton.html Zhang, Tongjie Y., and Ching Y. Suen. \u0026quot;A fast parallel algorithm for thinning digital patterns.\u0026quot; Communications of the ACM 27, no. 3 (1984): 236-239. K-means Clustering, https://en.wikipedia.org/wiki/K-means_clustering Lorensen, William E., and Harvey E. Cline. \u0026quot;Marching cubes: A high resolution 3D surface construction algorithm.\u0026quot; In Seminal graphics: pioneering efforts that shaped the field, pp. 347-353. 1998. File Format Support\r#\rThe support of Adobe formats (writing .psd and reading .abr) follows the official specification[1]. In addition, the parsing of brush files also refers to the description from Just Solve the File Format Problem[2] Wiki page and GIMP's source code[3].\nThe support of GIMP .gbr brushes follows the developer documentation[4].\nA Procreate brush is an archive with image files and PLIST configurations. A Clip Studio Paint .sut brush is an SQLite database. Both formats can be parsed by the Python Standard Library.\nAdobe Photoshop File Format Specification, https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/ Just Solve the File Format Problem, http://fileformats.archiveteam.org/wiki/Photoshop_brush https://github.com/GNOME/gimp/blob/master/app/core/gimpbrush-load.c The GIMP Paintbrush File Format, https://github.com/GNOME/gimp/blob/gimp-2-10/devel-docs/gbr.txt "},{"id":2,"href":"/nijigp/docs/functionality/polygon/bool/","title":"Boolean","section":"- Polygons -","content":"\rBoolean\r#\rNijiGPen provides following 2D boolean operations on the closed paths of two or more strokes:\nUnion (Sum, OR) Difference (Subtract, NOT) Intersection (AND) Exclusive (XOR) These functions are realized by calling the Clipper library. Please check the link for more details.\nEdit Mode Operators\r#\rThere are multiple buttons in the Edit mode panel, which are shortcuts of the same operator. This operator takes the paths of selected strokes as the input, and generate new strokes which are results of the boolean operation. You can choose to keep the input strokes or delete them.\nIt is possible, but not recommended to select strokes from multiple layers, since it is not intuitive to judge in which layer the output strokes should be generated and how they should be arranged.\rStroke Attributes\r#\rThe output strokes inherit the point attributes of the input strokes, including radius, strength, depth and vertex color. However, if the input strokes have different stroke attributes, e.g., the fill color and the assigned material, the output strokes can only choose one of them to inherit. There is an option to specify the criterion for such inheritance.\nCases of 3 or More Shapes\r#\rThe expected result of two input strokes is straightforward. However, with three or more input strokes, there may be multiple ways to finish the operation.\nThe figure above is an example of performing the Difference operation on 3 shapes. The numbers of Subjects and Clips need to be specified in the options.\nThe sequence of multiple Boolean operations may also affect the final result:\nIn Blender 4.2 and earlier versions, the operations are performed following the user's selection sequence of strokes. In Blender 4.3 and later versions, the selection sequence is no longer available. The operations are performed following the stroke arrangement/display sequence. Fracture\r#\rFracture is another boolean operation. It detects the overlapping area of selected shapes, and breaks the shapes into smaller parts. The output shapes will no longer overlap with each other.\nDraw Mode Operators\r#\rThe boolean operators are also available in the Draw mode. In this mode, it will take the latest drawn stroke as the Clip, and perform the operation on each stroke overlapping with it in the same layer.\nBoolean Eraser Tool\r#\rIn addition to the panel button, a tool named Boolean Eraser is available in the viewport.\nBlender's native eraser tool removes vertices rather than area from a shape, and sometimes appears unintuitive. This add-on's eraser tool aims at resembling the experience of traditional painting software.\nThe user can use mouse or stylus to remove areas from a shape. Several brush options are available to assist drawing, including Brush Size, Smooth Level and Shape of Caps.\nWhen drawing in the 3D space and the strokes are far from the origin, the results of the Boolean Eraser may become unexpected because of perspective distortion. In this case, it is recommended to switch the view to orthographic projection.\r"},{"id":3,"href":"/nijigp/docs/functionality/io/brushes/","title":"Brush Import","section":"- Import/Export -","content":"\rBrush Import\r#\rThrough the Import/Export sidebar panel, the user can load brushes of some other painting software's file formats into Blender and extract their textures to create Grease Pencil materials/brushes. Currently, the following formats are supported:\n.abr brushes that are commonly used in Adobe Photoshop, GIMP and Krita. .gbr brushes of GIMP. .brush or .brushset files exported from Procreate. .sut brushes exported from Clip Studio Paint. Please be sure to follow the license and terms of service of the original brush, especially for those acquired from an asset store, which usually prohibits some behaviors such as redistribution.\nIn addition, author information may not be preserved when importing a brush. If the brush requires attribution, please do it manually.\nIt may take a long time to parse high resolution (e.g. 2500px * 2500px) brushes, because the brush images need to be uncompressed. The time further increases if the file contains multiple brushes.\nIf you want to use the high resolution brushes repeatedly, you may consider save the brushes in a .blend file and link/append from it in the future, which may be faster than importing the brushes all over again.\nBrush Parameters\r#\rSince all these brush formats are designed for raster graphics and work in a different way from Grease Pencil, this add-on in fact only extracts the images from the brush file and use them as textures of new materials/brushes. All the original brush parameters will not be preserved.\nYou can select an existing Grease Pencil brush as a template in the import options. All newly generated brushes will use the parameters of this template brush.\nColor Modes\r#\rExcept some RGB .gbr brushes (which are not very common), A brush usually has only a single color channel as the texture. You can choose to use this channel as either alpha/transparency or the grayscale color in the import options.\nWhen using the channel as alpha, you can specify black or white as the texture color.\nSave Brush Icons\r#\rDespite the brush textures saved in the .blend file, the brush thumbnails shown in the Tool panel are separate image files, and have to be saved outside the .blend file.\nThere is an option specifying where to save these files. Deleting them will stop the brush from showing its thumbnail. Nevertheless, the brush itself will not be impacted.\nAdditional Notes\r#\rGIMP Brushes\r#\rThough not very common, some .gbr brushes are polychrome with 3 channels. Their textures can be parsed as RGB images into Blender.\nProcreate Brushes\r#\rPlease note that only third-party brushes can be imported into Blender. When Procreate exports a default brush, the file contains only brush parameters, but not textures, which cannot be used by software other than Procreate itself.\nA Procreate brush can use an additional texture called Grain. Since a Grease Pencil material cannot use multiple textures in this way, this grain texture will be separately imported as a material with a fill texture.\nThe add-on can read some parameters from Procreate brushes and convert them to Blender brush parameters. However, it is not guaranteed that the display and user experience can be perfectly reproduced.\nSUT Brushes\r#\rClip Studio Paint has some brush features that are not available in Blender.\nDuo color is not supported, while the texture can be imported in black and white. You may want to set a smaller color blend value for imported duo-color brushes to achieve a better result. One .sut brush may have multiple textures, which are sampled randomly during drawing. Since Blender does not support multiple textures, each texture will be converted to a separate brush. (The example brushes shown in this page is from the SeerStuff set created by SeerLight.)\n"},{"id":4,"href":"/nijigp/docs/functionality/animation/frame_animation/","title":"Frame Animations","section":"- Animations -","content":"\rFrame Animations\r#\rMultiframe Operations\r#\rGrease Pencil has a Multiframe Tool allowing users to draw or edit on multiple frames at the same time. Some of NijiGPen's operators in the Edit mode support this feature. With the Multiframe tool enabled, they are performed on all selected frames, instead of the active frame.\nSome operators have options that are only available in the multiframe mode, which are designed for making various animated effects. These options are:\nFalloff option of the polygon Offset and Sweep operators. Stop-Motion Animation option of the Mesh Generation operators. Animation Sequence option of the Sketch Cleanup operators. Baking Rigging to Keyframes\r#\rThe Bake Rigging to Keyframes button in the Weight Paint mode will disable the armature deformation and convert the bone animations to keyframe animations instead. This will allow users to further modify each frame's strokes.\nCurrently, this operator is implemented in an inefficient way. Therefore, it may take a long time if the number of strokes or frames is large.\r"},{"id":5,"href":"/nijigp/docs/get_started/installation/","title":"Installation","section":"Get Started","content":"\rInstallation\r#\rDifferent from most Blender add-ons, NijiGPen relies heavily on third-party Python packages. It is recommended to read the Python Packages page for more details.\nRequirements\r#\rBlender 3.3 ~ 4.2 Blender 4.3 (still experimental) (The add-on focuses majorly on stable, especially LTS versions. It is not guaranteed that all functions can work well in alpha or beta versions of Blender.)\nInstallation Steps\r#\rDownload the archive file from the GitHub Release page. Please avoid downloading the source code ZIP directly, since it may contain untested changes.\nIn Blender, open [Edit]-\u0026gt;[Preferences]-\u0026gt;[Add-ons] and click the Install button to load the archive. Enable the installed add-on.\nCheck the dependency summary to decide which Python packages are needed. Install them in the Preferences panel. Internet connection is required. Upgrade\r#\rBlender Upgrade: After upgrading Blender to a new version, the Installation Step 3 (Dependency Management) should be executed again.\nAdd-on Upgrade: If you want to replace the installed add-on with a newer version, it is recommended to remove the old version and restart Blender before installing the new version.\nRemoval\r#\rRemoving the add-on will not automatically remove the Python packages it installed. Please manually remove them using the buttons in the Preferences panel before removing the add-on itself.\n"},{"id":6,"href":"/nijigp/docs/functionality/mesh/generation/","title":"Mesh Generation","section":"- Meshes -","content":"\rMesh Generation\r#\rNijiGPen allows users to convert a Grease Pencil stroke to a mesh object (either planar or 3D). This can have multiple usages, such as:\nAdding the 3D shading effect to a 2D painting. Quick modeling from sketches. A stroke will be treated as a closed shape during mesh generation. Therefore, the line-only strokes may look different after the generation. You may either ignore them in the options or convert them to outlines first.\rPre-Processing\r#\rSampling the stroke with equal point intervals and/or smoothing the stroke may improve the quality of generated mesh. Therefore, shortcuts of some Blender native operators are placed here. Please refer to another page for more information.\rOffset Method (Frustum)\r#\rThe Frustum button provides a relatively simple way of converting each selected stroke to a mesh. It can be regarded as a 3D extension of the 2D Offset method.\nShape Style\r#\rThis method performs 2D insetting on each selected stroke for multiple times and extrudes each output path along the depth axis to make a 3D mesh. The user can determine the count and amount of 2D insetting to perform, as well as the style to generate depth.\nPost-Processing\r#\rThe 2D offset/inset operation may result in output vertices very close to each other, which may incur shading glitches. Options are provided to improve the topology of the output meshes, including vertex merging and remeshing.\nNormal Interpolation Method\r#\rThe Interpolation button is a more advanced mesh generation operator with more options to tune the output geometry.\nMesh Style\r#\rFirst, the algorithm will generate new vertices inside the stroke contour. Two styles are available:\nTriangulation: This style divides the shape into triangles. Furthermore, the user can choose to use either the triangle library or Blender's native method to achieve this. The triangle library generates better-quality mesh with each face having a similar area. However, it is not available for Apple silicon devices. This method will generate denser vertices near the contour to make the shading looks better. Grid: Based on Knife Project with a grid mesh, this style ensures each face to be a square. However, the faces close to the boundary may be 5-gons. Normal/Height Calculation\r#\rSecondly, the algorithm determines the height/depth of each new vertex. By default, a normal map will be generated according to the contour shape. In this way, though the generated mesh is a 2D planar, it has a 3D shading look reacting to different light sources in the space.\nThe user can also choose to generate a real 3D structure by changing the Mesh Type option. Two methods are available converting normal vectors to heights. The Advanced Solver option tends to generate smoother transition of heights. It may has better results than the basic method when the contour contains some sharp angles, but also requires longer processing time.\nThe Max Vertical Angle and Vertical Scale options determine the maximum depth of the generated mesh. With a negative value of either option, a concave geometry will be generated instead of a convex one.\nOpen Areas\r#\rBy default, all boundary vertices, which are the original points of the input stroke, have zero depth. By assigning a weight group in the Open Area Group option, points with non-zero weights are no longer pinned to the working plane and will leave some openings on the boundary. The option Fading Out can make such vertices transparent.\nThe user can also make holes inside a mesh. Input strokes with a holdout fill material are regarded as holes. Please refer to the following instructions.\nColor and Material\r#\rVertex Colors\r#\rThe vertex color of the generated mesh is determined by the fill color of the input stroke. Currently, only the Solid fill is supported. Gradient or Texture fill is not supported yet.\nThe normal interpolation method can also use the line color instead. If line points have more than one vertex colors, the color vector will be interpolated for the inner vertices just as the normal vector.\nPresets\r#\rThe add-on provides with some preset materials which can be selected from a list during the generation. The available options may vary depending on:\nThe mesh type: planar or 3D The render engine: Eevee or Cycles Custom Materials\r#\rBesides the presets, the user can also assign other materials to the generated meshes. Most Blender materials are expected to be compatible. The geometry information is stored in the following attributes:\nColor for both generation methods. NormalMap, Depth, UVMap for the normal interpolation method. "},{"id":7,"href":"/nijigp/docs/get_started/installation/dependency/","title":"Python Packages","section":"Installation","content":"\rPython Packages\r#\rNijiGPen's functionality relies on some third-party Python packages, which have to be separately downloaded and installed. If you have no experience with Blender add-ons that have similar requirements, it is strongly suggested to read this page before using the add-on.\nDependency Summary\r#\rThe table below lists the packages required for each type of operation. Lacking a package will not affect operations that do not require it. For example, if you install this add-on just to import brushes and render PSD files, then you do not need to take any actions mentioned in this page.\nFunction PyClipper Scipy \u0026amp; SkImage Triangle Polygon (Bool, Offset \u0026amp; Sweep) Yes Shading Calculation Yes Yes Line Fitting Yes Line Shaping (Pinch, Taper) Smart Fill Yes Yes Mesh Generation [See Below] Yes Optional Optional Rigging Using Mesh Rigging Using Hints [See Below] Optional Yes Line Art Import Yes Color Image Import Yes Yes Brush Import SVG \u0026amp; Palette Paste PSD Render Mesh Generation: Only pyclipper is a mandatory requirement. However, the other packages are optional to enable some enhancements of the Interpolation operator:\nscipy enables an advanced solver to calculate vertex depth. triangle enables an option to improve mesh quality, i.e., more uniformly distributed vertices. Rigging Using Hints: pyclipper is required only when using lasso-shaped hints.\nImpact of Operating Systems\r#\rThe add-on is available and has been tested in Windows, Linux and MacOS. However, there may be some specific issues in each OS:\nWindows\rDepending on the way Blender is installed, some additional attentions may be needed besides the normal package installation process.\nPortable or Steam: No additional action required. Official Installer: If Blender is installed in a system folder (e.g., C:\\Program Files\\Blender Foundation\\), it is recommended to run Blender as administrator to ensure the dependencies installed correctly. Microsoft Store: A custom package path is required to install packages. Normally, this will be handled automatically. Please refer to a later section for more information. MacOS\rThe triangle package is not fully tested for Apple silicon (M1/M2/M3) devices. It is possible that the package cannot be successfully installed. If that happens, please simply skip installing it. It has only minor negative effects.\rPackage Installation\r#\rTo install Python packages, the most straightforward way is the dependency manager in the add-on setting of the Preferences panel.\nClick the \u0026quot;Check\u0026quot; button to detect which packages have been installed, and click \u0026quot;Install\u0026quot; button for those missing (Internet connection is required).\nThe logs during the installation will be printed in the panel, which will also indicate if the installation is successful. The \u0026quot;Remove\u0026quot; button works in the similar way to uninstall packages. However, it requires Blender to be restarted to apply the changes.\nIf the installation fails, the reason may be shown in the logs. You may also consider reading the following sections about the alternative methods and the FAQ.\nAlternative Method 1: Custom Package Path\r#\rNormally, packages are installed in Blender's directory. However, in the Custom Package Path option, an additional path can be assigned for Blender to find and load the packages from. This option may be useful in the following scenarios:\nYou have multiple instances of Blender and/or Python installed, and do not want to download the packages repeatedly. You do not have the write access to the Blender directory (e.g., when Blender is installed through Microsoft Store). In the second case, the add-on will try to find this path automatically during the package installation. If that does not succeed, you may consider checking the following paths, which are some common places that packages may be installed to:\n\u0026#34;[Your Blender Directory]/3.x/python/lib/site-packages\u0026#34; (Windows) \u0026#34;%USERPROFILE%\\AppData\\Roaming\\Python\\Python310\\site-packages\u0026#34; (Linux) \u0026#34;~/.local/lib/python3.10/site-packages\u0026#34; Alternative Method 2: Manual Installation\r#\rThe Python packages are installed and managed by pip. For Python users knowing how pip works, the required packages can also be installed manually using the commmand line or terminal:\nEnter Blender's directory in the command line. An official manual is available. Enable the pip module: ./python -m ensurepip --upgrade Install packages: ./python -m pip install pyclipper triangle scikit-image You may consider these options when using pip: --no-cache-dir, --force-reinstall, --only-binary.\rFAQ\r#\rThe package installation succeeded, but the package status is still \u0026quot;Not Installed\u0026quot;.\rThis usually happens when you do not have the write access of the Blender directory, and the packages are automatically installed somewhere else. The path is usually shown in the logs. Please check if there are some lines containing a path ending with site-packages. If such a path can be found in the logs, refer to the Custom Package Path method and enter this path.\rBlender stops responding after hitting the Install button.\rIt is common that the download and installation may take some time. However, if Blender has no reponse for a long time, there might be network issues. Please make sure you have the Internet connection, and maybe use VPN if necessary.\nIt is possible that the display of logs can be lagged, until the operation finishes. To see the logs in real time, the same messages will also be shown in [Window] - [Toggle System Console] and without lags.\n"},{"id":8,"href":"/nijigp/docs/tips/scene_setup/","title":"Scene Setup","section":"Tips","content":"\rScene Setup\r#\rBlender comes with a template start file \u0026quot;2D Animation\u0026quot; that is convenient for painting. However, there are also some tricky parts in setting up the scene, especially when we put Grease Pencil and 3D objects in the same scene, including the meshes generated by this add-on. Here are some tips written in the form of FAQ.\nWhy cannot I see any shading effect when I generate meshes from Grease Pencil?\rThe default 2D Animation scene does not have any light sources. So we have to add some light objects to the scene ourselves.\nIn addition, please change the Viewport Shading to Render Preview mode and make sure that the scene lights are enabled.\nIf you do not want to set light sources, you can try the MatCap materials when generating meshes, which have the lighting information baked in and do not need scene lights.\nWhy is the lighting on 2D and 3D objects not consistent?\rThe environment background colors for 2D and 3D objects are not the same. In the [Scene]\u0026gt;[World] panel:\nthe lighting of 3D objects is determined by Surface and Volume tabs, but the lighting of Grease Pencil is determined by the Viewport Display tab. Please make sure that these two color values are the same if you want to make the lighting more consistent across all objects.\nWhy is the color drawn on the canvas slightly different from my material setting?\rYou may notice that the color displayed in the viewport is slightly different from the color you selected in the Brush or Material settings. This can cause some problems, such as getting the wrong color when using the Eyedropper tool.\nThis happens because the default background color is not actually white, although it looks very similar. The exact color is #F9F9F9.\nTo keep the color as it is, you can either set the viewport background color to pure white or uncheck the \u0026quot;Use Lights\u0026quot; option of the Grease layer.\nWhy does Grease Pencil obstruct all 3D objects regardless of depth, unlike what I see in the preview?\rThere are two options determining whether Grease Pencil will be rendered above all 3D objects:\nIn the [Scene]\u0026gt;[ViewLayer] panel, when Z pass is disabled (as by default), Grease Pencil objects will be rendered above all 3D objects. (But in the preview, it appears at the correct location.) In the [Object] properties panel, when \u0026quot;In Front\u0026quot; is checked in the Viewport Display tab, this Grease Pencil object is both rendered and previewed at the top. "},{"id":9,"href":"/nijigp/docs/functionality/line/fit/","title":"Sketch Cleanup","section":"- Lines -","content":"\rSketch Cleanup\r#\rNijiGPen's line operators provide functionality that helps turn raw sketches into final line art. A raw sketch usually contains repeated strokes, line splits, and line gaps that require a lot of manual effort to clean up. The Line Fit operators can speed up this process by merging multiple strokes into a single, smooth stroke.\nFit Sketch to Single Line\r#\rThe major way of using this function is from the sidebar panel in the Edit mode. The Single-Line button turns all selected strokes in the active frame to one new stroke.\rThe process of merging multiple strokes is automatic. However, in order to get a smooth output, there are two options to configure:\nLine Spacing determines a range, within which the lines drawn in parallel will be smoothed. Smoothness uses either Bézier or vertex-level method to make the output stroke smoother. Basically, they control the smooth level in two orthogonal directions, which is indicated in the following figure:\nInherit Point Attributes\r#\rBy default, the radius of the output stroke points is determined by whether the sketches are densely or sparsely drawn. The point strength/opacity will be set to 1. However, the user can also choose to use the strength/radius value from the input strokes.\nVertex color and line UV can also be inherited from input to output.\nMultiframe Fit and Interpolation\r#\rWhen Multiframe mode is enabled, and input strokes are from more than one keyframe, the operator will generate a new stroke for each keyframe.\nThe option Animation Sequence can perform a further optimization to the output strokes to ensure that more frames can be interpolated between the input keyframes smoothly.\nFit Sketch to Multiple Lines\r#\rSometimes the sketch is complex, and the user may want to convert it to multiple lines instead of a single one. The Multi-Line button will attempt to categorize the input strokes into clusters, and perform the line fit for each cluster separately.\nThe algorithm measures the distance between each pair of input strokes in a pointwise manner to determine which strokes belong to the same cluster.\nThe number of clusters is important, as shown in the figure above. There are several options to tune this value:\nBy Absolute Distance: Specifying a length as the maximum distance between strokes in the same cluster. By Relative Distance: Using a ratio of the stroke length as the maximum distance. By Number: Setting the maximum amount of clusters. Cluster Select\r#\rThe Cluster Select button applies the same criterion to find similar strokes (i.e., having a small pointwise distance) with the selected ones. However, it enlarges the selection instead of fitting the strokes. This operator can be used to select strokes which may belong to the same part of the drawing.\nFit Sketch in Draw Mode\r#\rThe Line Fit function can also be used in the Draw mode. In this mode, the user should assign the layer containing the sketch as the Reference Layer, and then draw the line art in a new layer. The operator will refine and smooth the latest drawn stroke according to the sketch.\n"},{"id":10,"href":"/nijigp/docs/functionality/line/","title":"- Lines -","section":"Functionality","content":""},{"id":11,"href":"/nijigp/docs/get_started/basic_usage/","title":"Basic Usage","section":"Get Started","content":"\rBasic Usage\r#\rUser Interface\r#\rNijiGPen creates new user interfaces to trigger its functions in the following places of Blender.\nSidebar Panels\r#\rA tab named NijiGP will appear in the sidebar of the 3D Viewport, if the active object is Grease Pencil and the mode is Draw, Edit or Weight Paint. This is the major way of calling NijiGPen's functions.\nNijiGPen operators are categorized in several panels. Depending on the current mode, different panels or operators may appear.\nThese operators do not have default shortcut keys. However, an option [Assign Shortcut] is available in the operator button's right-click menu.\nTools\r#\rNijiGPen adds several new tools in the Toolbar of Grease Pencil Edit and Draw modes. The tool icons have a \u0026quot;2D\u0026quot; mark on them.\nThese tools have the same effect as the corresponding operators in the sidebar panel. However, they allow you to tune the parameters with mouse dragging instead of typing numbers.\nViewport Buttons (Optional)\r#\rNijiGPen also adds some buttons at the bottom of the 3D Viewport window. They are shortcuts of the following functions:\nUndo/redo Tilt the canvas Arrange selected strokes forward/backward The purpose of these shortcut buttons is to enhance the user experience on touchscreens (e.g., Microsoft Surface), inspired by popular painting/design software on tablets. They can be triggered by either the mouse or a stylus.\nIf you do not need these buttons or find them conflicting with other add-ons, you can change their position or turn them off in the setting of Preferences panel.\r2D Working Plane\r#\rMost of the add-on operators work in a 2D plane. If you are working with Blender's 2D Animation template (using X-Z plane by default), there would be no problems. However, when working in the 3D space (e.g., painting on the surface of an object), the way of determining the 2D working plane should be paid attention to.\nIn the default mode (\u0026quot;Auto\u0026quot;), the add-on first estimates the coordinates of all input stroke points to determine the vectors of two most important dimensions. Then it uses the current view to determine the front/back and up/down directions. Please avoid selecting strokes belonging to more than one 2D plane as the input. In that case, the estimation can be wrong. (A warning message will show up when it happens.) There are also other modes available, including using the current view, or using an orthogonal plane (X-Y, X-Z or Y-Z). It can be set in the Global Setting panel. Applying a rotation in a Grease Pencil layer's attribute may disturb the detection of the working plane. If you want to use layer rotation with NijiGPen, please make sure to check the Use Transform of Active Layer option and process strokes from a single layer per operation.\nOn the other hand, applying a rotation on the object itself or its parent has no negative effect on the plane detection.\n"},{"id":12,"href":"/nijigp/docs/developer_notes/data_structures/","title":"Data Structures","section":"Developer Notes","content":"\rData Structures\r#\rDespite the new operators, this add-on prefers an unobtrusive style that does not change the original way that Blender's objects work. However, some operators must create new properties/attributes in an object to store additional information. This pages list all new data structures created by the add-on.\nAdd-On Registering\r#\rAll add-on operators are registered under bpy.ops.gpencil with the name prefix nijigp_. The add-on chooses gpencil as the category instead of creating a new one, because this allows users to assign shortcut to each operator.\nThe add-on stores global setting options by defining properties with the name prefix nijigp_ in bpy.types.Scene.\nCustom Properties\r#\rMaterials\r#\roriginal_material_index: Operators such as Hole Holdout may generate new materials from existing ones. The new material uses this property to mark the material slot number of the original material. Objects\r#\rMesh objects generated by this add-on from Grease Pencil strokes have following properties defined:\nnijigp_mesh: The type of the mesh. Currently, it can be either planar or 3d.\nnijigp_parent: A pointer to the Grease Pencil object that generates this mesh.\nThe parentship needs to be stored in this way persistently, because Rigging Operators may change the parentship of involved objects. Mesh Attributes\r#\rMeshes generated by this add-on use attributes for shaders and Geometry Nodes. Besides the regular attributes like Color and UVMap, there are also new ones defined:\nNormalMap: The normal vector calculated by the Normal Interpolation operator.\nDepth: A Float representing the height/depth of each vertex, normalized to 0~1 range.\nThis value is deduced from the normal vector, which may not be the same with actual vertex coordinate. Currently, none of the default shaders uses this attribute. However, the user can create their own shaders with it. start_frame, end_frame: Integers marking the frame range of the stroke generating this mesh. The Stop-Motion Animation option will insert a Geometry Nodes group to show/hide the mesh according to these values.\nAll of these new attributes are vertex attributes.\nGrease Pencil 3.0\r#\rThis add-on was primarily developed for Blender 3.3 ~ 4.2 with Grease Pencil 2 (GPv2). In Blender 4.3 the Grease Pencil module is completely rewritten as 3.0 (GPv3), using a completely different set of Python APIs without backwards compatibility.\nTo maintain the functionality of the add-on for both GPv2 and GPv3, a module api_router.py is used to provide a compatibility layer. It has two main tasks:\nSome keywords/attributes/operators have different names but similar functions in GPv2 and GPv3. The compatibility layer will choose the correct name to call depending on the version of Blender. Some important APIs, including Stroke and its collection, as well as StrokePoint and its collection work in distinct ways in GPv3, which break the add-on operators. These GPv3 APIs are no longer used by the add-on. Instead, a set of equivalent APIs are developed that emulate the behavior of the GPv2 APIs using GPv3 data. This allows the other add-on modules to manipulate strokes and points without being aware of the Blender version most of the time. The emulation approach is possible because GPv3 supports defining custom attributes that can be used in Geometry Nodes. To make the emulated APIs as capable as GPv2, the add-on defines several new attributes named .nijigp_*:\n.nijigp_hash: A random large integer assigned to each stroke as a unique identifier, making each stroke persistently traceable even if its index changes. .nijigp_new: A boolean value indicating whether a newly created stroke has not been configured. In GPv2, a new stroke has no points. However, a GPv3 stroke comes with a point when created. This attribute works as a reminder that the first point has not been configured. .nijigp_weight_proxy_%d: A number value for each point. Currently, GPv3 has difficulty accessing the vertex weights via Python. The emulator API accesses this attribute instead, and then copies the value to the actual weight via Geometry Nodes. This workflow may be improved in the future. "},{"id":13,"href":"/nijigp/docs/get_started/","title":"Get Started","section":"Docs","content":""},{"id":14,"href":"/nijigp/docs/tips/limitations/","title":"Limitations","section":"Tips","content":"\rLimitations\r#\rThe add-on has a number of limitations in different aspects, including:\nUnfinished features of the add-on itself, which may be improved in future releases. Limitations due to Blender's own design, which may lead to different behaviors from common graphics software. This page lists limitations which are general to multiple operators. Besides it, the constraints of 2D space can be found in Basic Usage. The limitation of each single operator will be recorded in their own page.\nShape of a Stroke\r#\rThe performance of the add-on may deteriorate with input strokes of certain shapes:\nPlease avoid using self-overlapping strokes. Unlike common vector formats such as SVG, Blender does not define a fill rule and the rendering of the overlapping parts cannot be guaranteed. Most operators ignore the overlapping parts automatically, but sometimes it also causes crashes. To eliminate these parts, you can use the Offset operator with a value of zero. It is also recommended not to have too few points or unevenly distributed points along the stroke, as this can lead to poor quality mesh generation or line cleanup results. The Resample button in the add-on panel can be used to quickly redistribute the stroke points. Holes\r#\rBoth this add-on and Blender itself have limitations supporting fill shapes will holes inside.\nBlender does not allow holes in a stroke, but some add-on operators like Boolean, Offset and SVG Paste can result in holes. In such cases, the corresponding geometry will be created, but will not be transparent. To display holes in Grease Pencil, Blender provides with a Holdout property in its material setting. The add-on also has a Hole Holdout operator to automatically set this property for shapes inside other shapes. In addition, some operators of the add-on have special behaviors when the input strokes have the holdout property. The Mesh Generation operator (currently only for the interpolation method) can turn these strokes into real holes in the mesh. The Offset and Sweep operators have the option to inverse the operation direction for these strokes. Gradient Fill\r#\rCurrently the add-on does not have good support for gradient fill materials. When the add-on mentions the fill color in its options, it always refers to the base color, and the secondary color (which exists in the case of a gradient) is ignored.\nVertex Groups\r#\rAfter some operators, including Boolean, Offset, and Line Cleanup, the weights of vertex groups are not preserved. If you need them for modifiers or rigging (including the rigging functions of this add-on), it is recommended to assign weights after using these operators.\nGrease Pencil 3.0\r#\rThis add-on was primarily developed for Blender 3.3 ~ 4.2 with Grease Pencil 2 (GPv2). For Blender version 4.3 or higher, the Grease Pencil module is completely rewritten as GPv3. Most of the add-on operators are expected to work normally with GPv3. However, several issues exist.\nStroke Selection Order\r#\rProblem: In GPv2, Boolean operators in the Edit mode use the stroke selection order to determine the sequence of operations. In GPv3, it does not work.\nReason: GPv3 currently does not record the selection order. It is uncertain whether this function will be added back.\nCurrent Solution: The stroke display order is used in GPv3 instead.\nMissing Resample Operator\r#\rProblem: The Resample button in the add-on panel no longer exists in Blender 4.3.\nReason: The button is a shortcut of a Blender native operator. However, this operator is omitted in Blender 4.3.\nCurrent Solution: This issue is expected to be fixed in Blender 4.4.\nBoundary Strokes\r#\rProblem: The option to use boundary strokes as hints of Smart Fill does not work.\nReason: There is no boundary stroke in GPv3. It is uncertain whether this function will be added back.\nCurrent Solution: The Smart Fill operator is still functional. All other features are not affected.\nSince Blender 4.3 is the first release with many breaking changes, some problems may persist until 4.4 or even later releases. It is recommended to use Blender 4.2 LTS if you prefer stable performance.\nIf you want to experiment with GPv3 new features, please consider checking the issue board of Blender itself in addition to this add-on to track related issues.\n(All emojis in this page are designed by OpenMoji – the open-source emoji and icon project. License: CC BY-SA 4.0)\n"},{"id":15,"href":"/nijigp/docs/functionality/mesh/management/","title":"Mesh Management","section":"- Meshes -","content":"\rMesh Management\r#\rDuring the mesh generation, since each stroke will be converted to a separate mesh object, it is common to have many objects generated from the same Grease Pencil painting. This page will discuss the methods and options to handle multiple generated objects.\nMulti-Object Alignment\r#\rThis section exists in each mesh generation operator's option panel, defining how multiple generated meshes are aligned in the depth dimension.\nWith the Stack option enabled, objects will be sorted according to the sequence of the input strokes. The objects generated from upward strokes will be moved forward along the depth axis, so that they will not be sheltered by the ones generated from downward strokes.\nFor planar meshes with normal maps, a constant gap in the depth axis can be set between each generated object.\nFor 3D meshes, Overlap Tolerance determines the maximum portion of vertices which may be overlapped by downward objects. O% means no overlapping is allowed, just as the planar mesh case. 100% means allowing all overlapping which leads to no depth movement at all.\nBatch Operations\r#\rIn the sidebar panel, there are buttons to perform batch operations on all generated meshes of the active Grease Pencil object. The user can hide, show or delete all mesh objects at once.\nAnimation\r#\rMultiframe operations may also generate multiple mesh objects, since the strokes in each different frame are regarded independent. To avoid the objects from different keyframes interfering with each other, the Stop-Motion Animation option can attach a predefined Geometry Nodes group to the generated object, which automatically hides the object outside its keyframe range.\n"},{"id":16,"href":"/nijigp/docs/functionality/polygon/offset/","title":"Offset","section":"- Polygons -","content":"\rOffset\r#\rThe 2D Offset operation is performed on the path of a stroke to achieve inflating/deflating/beveling of the shape.\nAlthough Blender has some inset/bevel operators/modifiers, they are not available for Grease Pencil. Besides, compared with Blender's method, this add-on will not cause the self-intersection of the output shape.\nThese functions are realized by calling the Clipper library. Please check the link for more details.\nFrom Sidebar Panel\r#\rThe Offset button in the sidebar panel will offset each selected stroke with a given length value. A negative length value indicates insetting.\nShape Style\r#\rThere are 3 offset modes to select from:\nFill Mode: Inflat or deflat the shape towards the normal direction of each line segment. Line Mode: Inflat the outline of the stroke. Please notice that: A negative offset amount is meaningless in this mode. From Blender 3.4, there is an official operator Outline achieving a similar effect. Corner Mode: This mode is a combination of two Fill Mode offset operations in the opposite direction (e.g., an offset followed by an inset immediately). As a result, most points in the stroke are unchanged, but the corners will be \u0026quot;eroded\u0026quot;. This can achieve an effect of bevel. The corners of the output shape can also have different styles, including Rounded, Flat and Miter.\nColor Tint\r#\rA new vertex color can be assigned to the output strokes. With a tint color and the Keep Original option on, repeating the operator for multiple times can create a gradient coloring effect.\nFrom Toolbar\r#\rOffset operations can also be performed from the toolbar as a tool named 2D Offset. Instead of typing a length value, the offset amount is controlled by mouse dragging.\nThe offset mode can be switched by holding different keys:\nDefault: Fill Mode Ctrl: Corner Mode (Bevel) Shift: Line Mode "},{"id":17,"href":"/nijigp/docs/functionality/io/colors/","title":"Palette Import","section":"- Import/Export -","content":"\rPalette Import\r#\rThrough the Import/Export sidebar panel, the user can import some palette/swatch files which contain color information. The add-on will convert them to Blender palettes. Currently, the following file formats are supported:\n.aco files used by Adobe Photoshop and Clip Studio Paint. .swatches files used by Procreate. .xml files used by some online color scheme services such as Adobe Color. Text that contains hex color codes. Hex codes separated by either space or any symbol can be recognized, such as: #FFEE93 #F5D782 #E97878 #9B5151 ffee93f5d782e978789b5151 f3c969,edff86,fff5b2,d4fcc3,362c28 [\u0026quot;f3c969\u0026quot;,\u0026quot;edff86\u0026quot;,\u0026quot;fff5b2\u0026quot;,\u0026quot;d4fcc3\u0026quot;,\u0026quot;362c28\u0026quot;] Import Options\r#\rTints and Shades: This option generates multiple variants of each color imported, by changing the brightness of imported color. Clipboard Utility\r#\rIt is a common function for color scheme services to export XML or hex codes directly into the system clipboard. This add-on provides with a separate button in the same panel to parse the colors from the clipboard and import them into Blender with one click.\nRecolor with a Palette\r#\rThe add-on also provides with a utility to quickly color the drawing using the imported palette. By clicking the Recolor button in the sidebar panel and selecting a palette, vertex colors of the selected strokes/points will be replaced with the palette colors, according to either RGB or HSV similarity.\nAdditional notes for some options:\nNormalize: Without normalization, each selected point will be recolored independently. On the contrary, this option enables taking the overall balance of all input points into account. Preserve Saturation/Brightness: These options allow the user to keep some color attributes unchanged when applying the new color to a stroke/point. "},{"id":18,"href":"/nijigp/docs/functionality/animation/rigging/","title":"Rigging Utilities","section":"- Animations -","content":"\rRigging Utilities\r#\rAlthough Blender can automatically generate weights rigging Grease Pencil strokes to an armature, the result often requires heavy manual adjustment. NijiGPen provides with several alternative methods generating bone weights.\nThe rigging-related operations will show up in a panel when the current mode is Weight Paint.\nIt is recommended to add a Smooth modifier after the Armature modifier if the point movement looks unnatural.\rTransfer Weights from Meshes\r#\rThe Weight From Meshes button is a tool transferring the weights from rigged mesh objects to the current Grease Pencil object.\nThe operator requires an armature and one or more source mesh objects as the input. It sets the weights of the armature bones to stroke points according to the nearest vertex from the source mesh objects.\nIf the source objects are not rigged, the operator can rig them first using the With Automatic Weights parenting tool, and then perform the transfer, controlled by the option Use Existing Weights.\nSource Objects\r#\rFor 2D animations, one recommended way is to use the other operators this add-on provides, Smart Fill followed by Mesh Generation. The option Quick New Mesh Using Smart Fill does it automatically, using the bones as filling hints.\nMeshes generated by this option are relatively simple, taking only the active frame of the active layer into account. For more complex cases, it may be better to finish these operations manually.\rBesides the method above, the following ways may also be used to generate a silhouette:\nBlender's Fill tool with the inverted direction. A hand-drawn contour is also likely to work, which does not need to be very precise. Besides using the generated mesh, you can also assign an arbitrary mesh object, or all mesh objects from a collection as the source. For example, this option may be useful when drawing strokes on the surface of a 3D object to keep their bone animation consistent. In that case, please make sure to change to mapping option to 3D Nearest Vertex.\nUse Hints to Generate Pins\r#\rThe Pins from Hints button is another rigging tool that can be used for rubber hose animations of limbs. It does not require an existing armature as the input. Instead, by drawing some hint strokes, the operator will generate bones at the same position, and then rig the Grease Pencil using these bones by setting weights to nearby points.\nHint Strokes\r#\rThe hint strokes should be drawn in a separate layer. Currently, two types of hints are available:\nStick Shape: Each hint should be a straight line, drawn at the middle of a limb and perpendicular to it. It should intersect with the limb's outlines at both ends. The hint's start and end position determine the placement of a bone. All other point/stroke attributes have no impact on the result. Lasso Shape: This mode allows the user to precisely select which points to assign weights, by drawing a lasso surrounding them. The generated bone starts from the lasso's center, pointing to its start position. Bone Styles\r#\rThere are several options to transform the generated bones:\nBone Style: This determines whether the bone should start from the hint's center (Half) or cross the whole hint shape (Full). Bone Rotation: Setting it to +90 or -90 degrees can make the bones parallel to the limb. Set Bone Parent: This option sets the parent relationship between bones according to the drawn sequence of hints and the relative position. Please notice that the result sometimes needs manual adjustment. Other Options\r#\rThere are some other options which may impact the result:\nEnsure Non-Zero Weights: Enabling this option will make sure that every stroke point gets at least one bone weight, no matter how far it is from the hints. Otherwise, only points close to a hint will be assigned weights. Bind Single Bone to Stroke: In this mode, each stroke will be assigned to at most one bone. This prevents strokes from being distorted. "},{"id":19,"href":"/nijigp/docs/functionality/line/tuning/","title":"Stroke Tuning","section":"- Lines -","content":"\rStroke Tuning\r#\rThis group of operators is designed to perform some fine adjustments on the position and/or thickness of a line art.\nPinch\r#\rThis operator closes the gaps between each pair of selected strokes if any of their tips are close together. The user can set a Transition value to determine whether to move the whole stroke or just move the tips.\nThe operation does not apply for the case where 3 or more strokes have their tips in proximity. In that case, only two of them will be merged.\rBy enabling the Consider Intermediate Points option, this operator can also be used to process the case where a tip of one stroke is close to the middle part of another stroke. The line points in the contact region can be thickened, in order to emulate an effect of contact shadow.\nTaper\r#\rThis operator changes the thickness of each selected stroke to make it look more natural, for example, to emulate the pressure sensitivity without having the corresponding input device.\nIt changes the radius of points at:\nStarting/End Points: The user can decide the impact range. Turning Points: The radius will be changed according to the point curvature. By default, these points will be thickened, but the user can also choose to thin them. "},{"id":20,"href":"/nijigp/docs/functionality/mesh/","title":"- Meshes -","section":"Functionality","content":""},{"id":21,"href":"/nijigp/docs/functionality/","title":"Functionality","section":"Docs","content":""},{"id":22,"href":"/nijigp/docs/functionality/line/smart_fill/","title":"Smart Fill","section":"- Lines -","content":"\rSmart Fill\r#\rSmart Fill is an operator in the Draw mode. It fills an entire line art layer based on some color hints marked by the user. Compared with the Blender's default Fill tool, it has the following advantages:\nIt handles the gaps in the line art automatically. It is less likely to leave seams near the contour, or be intersected. Although the algorithms are different, the concept of this operation is similar to the Colorize Mask tool in Krita.\nFrom Sidebar Panel\r#\rSmart Fill can be accessed from the button in the sidebar panel. This method requires the user to draw color hints as strokes.\nInput/Output Layers\r#\rThe operation takes two input layers, one containing the line art (Line Layer), and the other containing the color hint strokes (Hint Layer). They must be distinct layers.\nThe operation then generates new strokes in an output layer (Fill Layer). It is possible, but not recommended to use the same layer as Fill and Hint, since it will be difficult to distinguish the output strokes from the input ones. To overcome it, there is an option specifying to use only Boundary Strokes as hints.\nHint Strokes\r#\rPoints in the hint strokes will force the nearby areas be filled with the same color. The color of a hint point is determined in the following way:\nIf the stroke/point has a vertex color, use it as hint. Otherwise, use its material color. If the stroke has its fill visible, use the fill color as hint. Otherwise, use the line color. Only the position and color of the hint strokes have an impact. Other point/stroke attributes, including the line thickness and strength will not affect the result.\nYou can use fill materials for the hint strokes. But only its contour points will be taken into account. The inner part has no effect.\rOutput Materials\r#\rThere are different ways to assign materials to the newly generated fill strokes:\nUse the same materials (and vertex colors if exist) as hint strokes. Use an existing material. Generate vertex fill colors for each stroke. For each color used as hints, generate a new material. If you tend to use existing materials, please make sure they are not line-only ones.\nFrom Toolbar\r#\rSmart Fill can also be used as a tool in the Draw mode, as an alternative of Blender's native Fill tool. It allows the user to fill an area will mouse clicks:\nLeft Click: Specifies an area to fill. Right Click: Specifies an area not to fill. Enter: Confirms the current results and exits the tool. ESC: Cancels the operation and exits the tool. In addition, mouse middle and side buttons can be assigned to Confirm or Cancel in Preferences.\nThe tool generates fill strokes in the active layer. By default, it also analyzes the line art in the same layer, while a more common way is to specify another layer as the line art in the topbar's option.\nCurrently, the tool does not support multiframe fill. In order to fill multiple frames at the same time, please use the sidebar method with hint strokes.\nPlease notice that Smart Fill may react slowly when the line art contains a large number of points. In this case, it is recommended to save your file before using this tool.\r(The example image used in this page is Portrait of Olga by Pablo Picasso in 1920.)\n"},{"id":23,"href":"/nijigp/docs/functionality/io/svg/","title":"SVG Import","section":"- Import/Export -","content":"\rSVG Import\r#\rThough Blender has its native function to import an SVG file as Grease Pencil, this add-on provides with another import operator extending the native one for more use scenarios. The operator has the following differences from the native one:\nSVG will be directly appended to the active Grease Pencil object, instead of creating a new one. The operator can be used in Draw and Edit mode, while the native one requires switching to Object mode. The add-on's SVG importer also has more features, as described in the next sections.\nAppend Multiple Files\r#\rThe user can append multiple SVG files to the active Grease Pencil object in a single operation. By default, each SVG file is placed in a separate layer.\nIf the Image Sequence option is enabled, the SVG files are treated as animation frames. Instead, they are placed in the same layer, each creating a new frame in the timeline.\nThe Reuse Materials option determines whether new materials are created for each imported SVG file, or whether the same materials are applied to all imported SVG files.\nClipboard Utility\r#\rSome graphic design software allow users to copy vector shapes as SVG code text, including a small amount of painting software such as Clip Studio Paint. This add-on provides with a separate button in the same panel to parse the SVG code from the system clipboard and append the image to the active Grease Pencil object.\n"},{"id":24,"href":"/nijigp/docs/functionality/polygon/sweep/","title":"Sweep","section":"- Polygons -","content":"\rSweep\r#\rThe Sweep operation drags stroke polygons along a given vector or path to create several effects, such as the pseudo-3D extrusion and shadowing.\nThe mathematical terminology behind this concept is Minkowski sum.\nFrom Sidebar Panel\r#\rThe Sweep button in the sidebar panel performs the operation on each selected stroke by typing the lengths of a 2D vector.\nShape Style\r#\rThe following 3 styles apply:\nExtrude: It turns the shapes into a pseudo-3D look. Outer Shadow: It is similar to the Extrude style but the output only contains the newly generated paths. Inner Shadow: It generates a rim inside the input stroke shape. If you need to turn strokes into real 3D objects instead of pseudo-3D ones, you may consider Mesh Generation operators instead.\rCurved Path\r#\rThe sweep path is not constrained to a straight line. By changing the Path Type option, the last selected stroke can be used as the path. The path itself will not be processed. Therefore, please select at least two strokes in this mode.\rProcess Holdout\r#\rSince material holdout is used to represent holes in a shape, it would look incorrect when sweeping it together with other shapes. Therefore, the following special rules can be applied:\nFor Extrude and Outer Shadow style, execute Inner Shadow for holes instead. If the holdout material is generated by this add-on's Hole Holdout operation, the material will be changed back to the non-holdout one. For Inner Shadow style, the holes are excluded from the input and ignored. Color Tint\r#\rA new vertex color can be assigned to the output strokes. With a tint color and the Keep Original option on, repeating the operator for multiple times can create a gradient coloring effect.\nFrom Toolbar\r#\rSweep operations can also be performed from the toolbar as a tool named 2D Sweep. Instead of typing numbers, the path vector is controlled by mouse dragging.\nThe style can be switched by holding different keys:\nDefault: Extrude Ctrl: Outer Shadow Shift: Inner Shadow "},{"id":25,"href":"/nijigp/docs/tips/","title":"Tips","section":"Docs","content":""},{"id":26,"href":"/nijigp/docs/functionality/animation/","title":"- Animations -","section":"Functionality","content":""},{"id":27,"href":"/nijigp/docs/developer_notes/","title":"Developer Notes","section":"Docs","content":""},{"id":28,"href":"/nijigp/docs/functionality/polygon/holdout/","title":"Hole Holdout","section":"- Polygons -","content":"\rHole Holdout\r#\rTo display holes inside a shape's fill, Blender has a unique mechanism in Grease Pencil that is different from most vector graphic editing software. Users need to manually enable a Holdout option in the material setting to make a stroke transparent.\nTo simplify this process, NijiGPen provides with an operator to automatically detect holes among selected strokes. If a stroke's path is completely inside another stroke's fill:\nIt will be arranged upward to display in front of the stroke it is in. It will be turned transparent by assigning a material with all attributes unchanged except the Holdout option being enabled. If such material does not exist, a new material will be created first. Interaction with Other Operators\r#\rThis operation is also executed automatically as a step in many other operators, including SVG Paste, Color Image Vectorization, Smart Fill and Mesh Generation.\nPlease also refer to the Limitation page for more information about processing holes.\n"},{"id":29,"href":"/nijigp/docs/functionality/io/vectorizing_images/","title":"Image Import","section":"- Import/Export -","content":"\rImage Import\r#\rThe Trace Image to Grease Pencil tool of Blender is limited to black and white input images. NijiGPen provides with operators vectorizing another two types of raster images.\nThese operators take either a single image or an image sequence as the input, and generate new strokes in the current Grease Pencil layer. The direction of the generated strokes is parallel to the current 2D working plane.\nSketches: Extracting the Line Art\r#\rThe Line Art button is an operator to convert an image to line-only strokes. It is recommended to select a material without fills enabled.\nCompared with most SVG-based editing software, an advantage of extracting the line art in Blender is the ability to preserve the thickness and color of the strokes, stored as point attributes.\nMedian Filter\r#\rSetting a non-zero value in the Median Filter Radius option will enable the median filter.\nThe filter should be used when the input image has heavy noise or grain. However, a large radius may also lower the processing speed and ignore some details from the image. Color Images: Quantization\r#\rThe Flat Color button is an operator that reduces the number of distinct colors used in an image. Then, each color of the image is traced separately to generate Grease Pencil strokes.\nYou can choose to either generate a new material for each color, or use a single material with multiple vertex fill colors.\nThis operator aims at color paintings in the flat style, rather than images with rich and gradient colors, e.g., real-world photos.\nIncreasing the number of colors in the import option may lead to better results for the latter case, but also causes a much longer processing time, and the result may still be far from ideal.\nGenerate Line Colors\r#\rThis method mainly focuses on the fill color of generated strokes, while there is also an option to determine whether the same color should be assigned to the line points.\nThe thickness and strength of the line are determined by the current brush.\nGenerate a Palette\r#\rAlong with the stroke generation, a palette can be generated which contains the colors extracted from the image. On the other hand, a palette can also be used as the input of the Color Source option, specifying which colors should be extracted. This may have the following use cases:\nTo import multiple images and guarantee their color sets are consistent. To perform the color transfer, i.e., applying the color style of one image to another image. Min Stroke Area\r#\rThis option determines whether to ignore a shape by its area. Shapes with 0 or a very small area may lead to problems when performing polygon or mesh generation operations. This option can filter them out.\nRender and Convert\r#\rThere is a shortcut button to automatically render the current 3D scene, and then convert the rendered image to Grease Pencil strokes. The input can be either the whole scene, or a specific object/collection. The operator also supports rendering an animation as multiple frames.\nThis operator can be combined with the Line Art Modifier to achieve a better result. It can detect the line art modifier with the same Source Type and Source Object/Collection, then bake the line art and project them to the same 2D plane as the vectorized colors.\n(The example images used in this page are Portrait of Olga by Pablo Picasso in 1920, and The Starry Night by Vincent van Gogh in 1889.)\n"},{"id":30,"href":"/nijigp/docs/functionality/io/","title":"- Import/Export -","section":"Functionality","content":""},{"id":31,"href":"/nijigp/docs/functionality/polygon/hatch/","title":"Hatch Fill","section":"- Polygons -","content":"\rHatch Fill\r#\rThis is an Edit mode operator to generate doodle or hatch patterns inside the selected stroke shapes. Various types of stylized shading or coloring effects can be achieved with different combinations of options.\nLine Styles\r#\rThe operator will generate a grid of points inside each selected shape, while there are multiple ways to connect these points as new strokes:\nSingle-Line Doodle: In this mode, all points will be connected together to ensure that each input stroke generates only one output stroke.\nPlease notice that it is possible for the hatch pattern to go out of the input shape, if the input shape is not convex. Doodles: In this mode, points will be connected as much as possible. Depending on the input shape, the hatch may break into multiple strokes.\nParallel Lines: In this mode, points only connect in one direction, which often leads to many output strokes for each input stroke.\nChoice of Materials\r#\rIt is recommended to set line-only materials for output. Depending on the Line Type (\u0026quot;Line\u0026quot; or \u0026quot;Dots\u0026quot;) and whether to use a texture or not, different effects can be achieved.\nNoise Options\r#\rThere are several options to randomize different attributes of the output stroke points, including direction, position, radius and UV. This feature can be useful when:\nGenerating hatch patterns with a hand-drawn look, or Using output materials with textures. (The example texture shown in this page is from the SeerStuff brush set created by SeerLight.)\n"},{"id":32,"href":"/nijigp/docs/functionality/io/psd_render/","title":"PSD Render","section":"- Import/Export -","content":"\rPSD Render\r#\rThe Multi-Layer PSD Render button renders each layer of the Grease Pencil object to a separate image, and then merge them together to a .psd file. The name, blend mode of each layer and the sequence of layers will be preserved. In this way, the image can be further edited in various popular image editing or painting software.\nBesides the Grease Pencil layers, there are two additional PSD layers rendered. One contains all non-Grease-Pencil objects, and the other is the scene background.\nCompatibility\r#\rDespite its popularity, the .psd file format is designed for internal use within Adobe software, but not for interchange. Given this and the difference between vector, raster and 3D graphics, only a limited subset of features is supported.\nDuring rendering, the following restrictions apply:\nLayer masks in Grease Pencil cannot be converted to Photoshop masks, because Photoshop has different mechanisms for representing masks. As a workaround, The option Bake Layer Mask can clip the rendered image according to its Grease Pencil masks. However, it works for positive masks only. Inverted (negative) masks will be ignored. Z-ordering in 3D space may not be preserved in the rendered image. Compression algorithms are not implemented yet. Rendered file size may be large. Saving the image again in another software will likely to reduce the image size to normal. Only a single frame can be rendered as one .psd file. Frame animations have not been supported yet. "},{"id":33,"href":"/nijigp/docs/functionality/polygon/shading/","title":"Shading","section":"- Polygons -","content":"\rShading\r#\rThis Edit mode operator generates shadow and light areas of selected strokes given a light source in the scene. This function can be used to fit the Grease Pencil art better into the Blender's 3D environment.\nThere are also some other functions related to 3D lighting and shading which belong to Mesh Generation operators.\nLight Source\r#\rThere are several options to assign a light source for shading calculation:\nConstant Vector: The user can type the direction (a 3D vector in the global space) and the power of a light source manually. Reference Object: By selecting an object in the scene, the location of the object will be regarded as point light source. Light Object: By selecting a light object in the scene, the add-on reads all necessary attributes (location, direction, power and type) of it to calculate shading. Please notice that only Point and Sun lights are supported. The reference object or the light object can have animation data. To generate animated shading, please refer to Multiframe Operations.\nShadow and Lighting Styles\r#\rThe outputs of this operator are new strokes that depict the shadow terminator lines of the input shapes. There are several options for the generated shadow and light strokes separately.\nShadow Strokes\r#\rThreshold: The algorithm checks the amount of light hitting the surface of the input shapes, and uses a threshold value to determine if an area is in the shadow. A higher value usually leads to larger shadow areas. The operator also allows an additional threshold value to generate 2-level shadows. Vertical Scale: This value determines how the algorithm assumes the 3D geometry of the input shapes. Taking a circle as an example, a large/medium/small vertical scale makes it shaded like a cone/sphere/disk. Negative values are supported for concave surfaces. Resolution: Higher resolution adds more details to the shadow but requires more time to calculate. The user can also specify a minimum area value to ignore shadows that are too small. Rim Light Strokes\r#\rThe setting of generated rim light strokes is simpler. The user just need to set the Width of such strokes.\nStroke Attributes\r#\rThe following attributes determine the look of the generated strokes:\nMaterial: The user can assign materials for generated light and shadow strokes separately. If not assigned, the output strokes will use the same material as input ones. Tint Color: By default, the vertex color of the generated strokes are the same as the input ones. The user can however apply a tint color to emphasize the shadows and lights. Comparison with Mesh Generation\r#\rThe visual effect made by this operator is often similar to the Mesh Generation operator with a toon shader. For pure 2D illustration purpose, this method may be more convenient since:\nThe shadows and lights are generated as editable Grease Pencil strokes. The terminator lines are usually smoother with less artifacts compared with a 3D mesh. However, there are also some limitations compared with the 3D method:\nOnly limited number of light sources and light types are supported. The lighting is also approximated. If changing the position/direction of the light source, the already generated strokes cannot correct themselves automatically. You may need to delete them and use this operator again. Only toon shading can be achieved. Cast shadows will not be generated. "},{"id":34,"href":"/nijigp/docs/","title":"Docs","section":"Introduction","content":""}]