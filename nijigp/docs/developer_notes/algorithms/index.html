<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Algorithm Design#This page provides an in-depth exploration of the algorithms utilized by this add-on, both for developers interested in vector graphics processing and for users wondering about the core principles underlying the add-on’s functionality.
It is less recommended to read the source code directly, since the code details are not excellent and still need refinement. Instead, this article focuses more on the mathematics behind each feature.
The add-on’s functions fall into two categories:">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="Algorithm Design" />
<meta property="og:description" content="Algorithm Design#This page provides an in-depth exploration of the algorithms utilized by this add-on, both for developers interested in vector graphics processing and for users wondering about the core principles underlying the add-on’s functionality.
It is less recommended to read the source code directly, since the code details are not excellent and still need refinement. Instead, this article focuses more on the mathematics behind each feature.
The add-on’s functions fall into two categories:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chsh2.github.io/nijigp/docs/developer_notes/algorithms/" /><meta property="article:section" content="docs" />


<title>Algorithm Design | NijiGPen Documentation</title>
<link rel="manifest" href="/nijigp/manifest.json">
<link rel="icon" href="/nijigp/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/nijigp/book.min.3bc88adb2893c54b24fa8617cb6dc6ca846aa5522c5275f3279db80d776e8d55.css" integrity="sha256-O8iK2yiTxUsk&#43;oYXy23GyoRqpVIsUnXzJ524DXdujVU=" crossorigin="anonymous">
  <script defer src="/nijigp/flexsearch.min.js"></script>
  <script defer src="/nijigp/en.search.min.8e6b919e6f1a43cced41cd3de22ef6c1a22701ae37573e0298c33ea05c06e44a.js" integrity="sha256-jmuRnm8aQ8ztQc094i72waInAa43Vz4CmMM&#43;oFwG5Eo=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/nijigp/"><span>NijiGPen Documentation</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>



  



  
    
  



<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/nijigp/svg/translate.svg" class="book-icon" alt="Languages" />
        English
      </a>
    </label>

    <ul>
      
      <li>
        <a href="https://chsh2.github.io/nijigp/zh/">
          中文
        </a>
      </li>
      
    </ul>
  </li>
</ul>











  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Get Started</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/get_started/installation/" class="">Installation</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/get_started/installation/dependency/" class="">Python Packages</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/get_started/basic_usage/" class="">Basic Usage</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Functionality</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>- Polygons -</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/polygon/bool/" class="">Boolean</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/polygon/offset/" class="">Offset</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/polygon/sweep/" class="">Sweep</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/polygon/holdout/" class="">Hole Holdout</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/polygon/hatch/" class="">Hatch Fill</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/polygon/shading/" class="">Shading</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>- Lines -</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/line/fit/" class="">Sketch Cleanup</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/line/tuning/" class="">Stroke Tuning</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/line/smart_fill/" class="">Smart Fill</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>- Meshes -</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/mesh/generation/" class="">Mesh Generation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/mesh/management/" class="">Mesh Management</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>- Animations -</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/animation/frame_animation/" class="">Frame Animations</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/animation/rigging/" class="">Rigging Utilities</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>- Import/Export -</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/io/brushes/" class="">Brush Import</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/io/colors/" class="">Palette Import</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/io/svg/" class="">SVG Import</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/io/vectorizing_images/" class="">Image Import</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/functionality/io/psd_render/" class="">PSD Render</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Tips</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/tips/scene_setup/" class="">Scene Setup</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/tips/limitations/" class="">Limitations</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Developer Notes</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/developer_notes/algorithms/" class="active">Algorithm Design</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/nijigp/docs/developer_notes/data_structures/" class="">Data Structures</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href=""  target="_blank" rel="noopener">
        ---
      </a>
  </li>
  
  <li>
    <a href="https://github.com/chsh2/nijiGPen/releases/download/v0.11.0/NijiGPen_Manual.epub"  target="_blank" rel="noopener">
        [EPUB Manual]
      </a>
  </li>
  
  <li>
    <a href="https://github.com/chsh2/nijiGPen/releases/download/v0.11.0/NijiGPen_Manual.pdf"  target="_blank" rel="noopener">
        [PDF Manual]
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/nijigp/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Algorithm Design</strong>

  <label for="toc-control">
    
    <img src="/nijigp/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#polygon-operations">Polygon Operations</a></li>
    <li><a href="#sketch-cleanup">Sketch Cleanup</a></li>
    <li><a href="#smart-fill">Smart Fill</a></li>
    <li><a href="#mesh-generation">Mesh Generation</a>
      <ul>
        <li><a href="#normal-vector-interpolation">Normal Vector Interpolation</a></li>
        <li><a href="#heightdepth-calculation">Height/Depth Calculation</a></li>
        <li><a href="#2d-shading">2D Shading</a></li>
      </ul>
    </li>
    <li><a href="#image-vectorization">Image Vectorization</a>
      <ul>
        <li><a href="#line-art-extraction">Line Art Extraction</a></li>
        <li><a href="#color-quantization">Color Quantization</a></li>
      </ul>
    </li>
    <li><a href="#file-format-support">File Format Support</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="algorithm-design">
  Algorithm Design
  <a class="anchor" href="#algorithm-design">#</a>
</h1>
<p>This page provides an in-depth exploration of the algorithms utilized by this add-on, both for developers interested in vector graphics processing and for users wondering about the core principles underlying the add-on’s functionality.</p>
<p>It is less recommended to read the source code directly, since the code details are not excellent and still need refinement. Instead, this article focuses more on the mathematics behind each feature.</p>
<p>The add-on’s functions fall into two categories:</p>
<ul>
<li>The first category comprises classical algorithms and I simply deploy third-party Python packages to perform them. For these functions, this page lists the names of the packages and the main algorithms for reference.</li>
<li>The second category consists of methods developed by myself learning mainly from academic projects. The documentation describes the main steps of each method and the research papers I used as inspiration.</li>
</ul>
<blockquote class="book-hint info">
  Since this is not a formal academic publication, for some well-known concepts I will cite Wikipedia pages as the source for convenience.
</blockquote>

<h2 id="polygon-operations">
  Polygon Operations
  <a class="anchor" href="#polygon-operations">#</a>
</h2>
<p>The polygon operations (Boolean, offset and sweep) are performed by directly adopting the <a href="https://www.angusj.com/clipper2/Docs/Overview.htm">Clipper</a> library without my own design. Several classic algorithms are implemented in Clipper:</p>
<ul>
<li>Boolean operations are achieved by the Vatti clipping algorithm<sup class="citation-ref">[1]</sup>.</li>
<li>Hole detection and offset are achieved by computing winding numbers<sup class="citation-ref">[2]</sup>.</li>
<li>Sweep operation is achieved by using Minkowski addition<sup class="citation-ref">[3]</sup>.</li>
</ul>
<blockquote class="citation-quote"><ol>
<li>Vatti, Bala R. &quot;A generic solution to polygon clipping.&quot; Communications of the ACM 35, no. 7 (1992): 56-63.</li>
<li>Chen, Xiaorui, and Sara McMains. &quot;Polygon offsetting by computing winding numbers.&quot; In International Design Engineering Technical Conferences and Computers and Information in Engineering Conference, vol. 4739, pp. 565-575. 2005.</li>
<li><a href="https://en.wikipedia.org/wiki/Minkowski_addition">https://en.wikipedia.org/wiki/Minkowski_addition</a></li>
</ol>
</blockquote>
<h2 id="sketch-cleanup">
  Sketch Cleanup
  <a class="anchor" href="#sketch-cleanup">#</a>
</h2>
<p>The purpose of sketch cleanup is to merge multiple 2D strokes with the similar shape into a single, smooth one. It looks like a curve fitting problem, but it is not trivial to solve:</p>
<ul>
<li>It is common that the input strokes cannot be represented by a function 
<link rel="stylesheet" href="/nijigp/katex/katex.min.css" />
<script defer src="/nijigp/katex/katex.min.js"></script>
<script defer src="/nijigp/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script><span>
  \(y=f(x)\)
</span>
 since a single <span>
  \(x\)
</span>
 may correspond to multiple <span>
  \(y\)
</span>
 values.</li>
<li>Modeling input strokes as <img src="../eq_param_model.svg" alt="\left{\begin{matrix} y=f(t) \ x=g(t) \end{matrix}\right." /> is also problematic, because it is hard to determine the parameter <span>
  \(t\)
</span>
 (i.e., the order of input points) among multiple input strokes.</li>
</ul>
<p>The method adopted here is to treat the input strokes as a set of unordered 2D points and then construct a curve from them. I refer to two research papers<sup class="citation-ref">[1][2]</sup> which share several common steps:</p>
<ol>
<li>Perform Delaunay triangulation<sup class="citation-ref">[3]</sup> on all input points and treat the result as a graph.</li>
<li>Calculate the minimum spanning tree (MST)<sup class="citation-ref">[4]</sup> of this graph.</li>
<li>Find the longest path between any two nodes in MST.</li>
</ol>
<p>These steps lead to a 2D path which is the output stroke, but it is usually not smooth enough. The two research papers have different ways further processing the stroke. Considering the time complexity, however, a distinct method is developed for this add-on:</p>
<ol start="4">
<li>For each point in the calculated longest path, find other input points (that do not belong to the path) in the neighborhood given a radius value. Average their coordinate of the normal direction.</li>
<li>Perform a B-spline fitting using <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splprep.html">SciPy</a> to get the final result.</li>
</ol>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css" />
<script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>
<style>
.swiper {
    max-width: 540px;
}
.swiper-pagination-bullet {
    width: 20px;
    height: 20px;
    text-align: center;
    line-height: 20px;
    font-size: 12px;
    color: #000;
    opacity: 1;
    background: rgba(0, 0, 0, 0.2);
}
.swiper-pagination-bullet-active {
    color: #fff;
    background: var(--doc-alt-color);
}
</style><div class="swiper sketch-cleanup-fig">
    <div class="swiper-wrapper">
      
    <div class="swiper-slide"><figure>
        <figcaption>Multiple input strokes to fit.</figcaption>
        <img src="../alg_fit_1.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Triangulation from the input point set.</figcaption>
        <img src="../alg_fit_2.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Get MST from the triangles.</figcaption>
        <img src="../alg_fit_3.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Get the longest path from MST.</figcaption>
        <img src="../alg_fit_4.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Smooth the longest path to get the final result.</figcaption>
        <img src="../alg_fit_5.png">  
    </figure></div>

    </div>
    <div class="swiper-pagination"></div>
</div>


<script>
    var swiper = new Swiper(".sketch-cleanup-fig", {
        pagination: {
        el: ".swiper-pagination",
        clickable: true,
        renderBullet: function (index, className) {
            return '<span class="' + className + '">' + (index + 1) + "</span>";
        },
        },
    });
</script>
<blockquote class="citation-quote"><ol>
<li>Lee, In-Kwon. &quot;Curve reconstruction from unorganized points.&quot; Computer aided geometric design 17, no. 2 (2000): 161-177.</li>
<li>Liu, Chenxi, Enrique Rosales, and Alla Sheffer. &quot;Strokeaggregator: Consolidating raw sketches into artist-intended curve drawings.&quot; ACM Transactions on Graphics (TOG) 37, no. 4 (2018): 1-15.</li>
<li><a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">https://en.wikipedia.org/wiki/Delaunay_triangulation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree">https://en.wikipedia.org/wiki/Minimum_spanning_tree</a></li>
</ol>
</blockquote>
<h2 id="smart-fill">
  Smart Fill
  <a class="anchor" href="#smart-fill">#</a>
</h2>
<p>LazyBrush<sup class="citation-ref">[1]</sup> is a tool that allows users to fill a line art based on some hint colors drawn on it. It is originally designed to process pixels of a raster image. This add-on adopts the concept of LazyBrush, but modifies the algorithm to make it work for vector arts.</p>
<p>The key idea is the max-flow min-cut theorem<sup class="citation-ref">[2]</sup>. The min-cut partitions a graph into two disjoint subsets. We use it to partition the points of the line art, and assign a color to each output subset, which is how the line art is filled.</p>
<p>The way of constructing a node graph from the vector line art is inspired by the research paper Delaunay Painting<sup class="citation-ref">[3]</sup>. The add-on performs Delaunay triangulation on the line art stroke points, and builds a graph with triangles as graph nodes. For each pair of adjacent triangles (sharing an edge):</p>
<ul>
<li>If the edge belongs to the line art, do not create a link between the two graph nodes.</li>
<li>Otherwise, create a weighted link. The weight is the length of the edge.</li>
</ul>
<p>The max-flow min-cut method requires source and sink nodes, which are triangles with two different hint colors. With the min-cut disconnecting source nodes from sink nodes, the graph is partitioned into two, which are the filling areas of these two colors. If there are <span>
  \(N&gt;2\)
</span>
 hint colors, just repeat this process for <span>
  \(N-1\)
</span>
 times.</p>
<p>The description above may be obscure since many details of the graph theory have to be involved. The figures below aim at providing an intuitive example about how this method works.</p>
<div class="swiper smart-fill-fig">
    <div class="swiper-wrapper">
      
    <div class="swiper-slide"><figure>
        <figcaption>Input line art and hint strokes.</figcaption>
        <img src="../smart_fill_alg_1.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Divide the line art into triangles.</figcaption>
        <img src="../smart_fill_alg_2.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Convert triangles to a node graph.</figcaption>
        <img src="../smart_fill_alg_3.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Partition the graph into two parts.</figcaption>
        <img src="../smart_fill_alg_4.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Fill each subgraph with one color.</figcaption>
        <img src="../smart_fill_alg_5.png">  
    </figure></div>

    </div>
    <div class="swiper-pagination"></div>
</div>


<script>
    var swiper = new Swiper(".smart-fill-fig", {
        pagination: {
        el: ".swiper-pagination",
        clickable: true,
        renderBullet: function (index, className) {
            return '<span class="' + className + '">' + (index + 1) + "</span>";
        },
        },
    });
</script>
<blockquote class="citation-quote"><ol>
<li>Sýkora, Daniel, John Dingliana, and Steven Collins. &quot;Lazybrush: Flexible painting tool for hand‐drawn cartoons.&quot; In Computer Graphics Forum, vol. 28, no. 2, pp. 599-608. Oxford, UK: Blackwell Publishing Ltd, 2009.</li>
<li><a href="https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem">https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem</a></li>
<li>Parakkat, Amal Dev, Pooran Memari, and Marie‐Paule Cani. &quot;Delaunay Painting: Perceptual Image Colouring from Raster Contours with Gaps.&quot; In Computer Graphics Forum, vol. 41, no. 6, pp. 166-181. 2022.</li>
</ol>
</blockquote>
<h2 id="mesh-generation">
  Mesh Generation
  <a class="anchor" href="#mesh-generation">#</a>
</h2>
<p>Among different mesh generation operators, the Offset/Frustum method uses the same algorithm as the polygon offset, while the normal interpolation method is based on a different principle.</p>
<h3 id="normal-vector-interpolation">
  Normal Vector Interpolation
  <a class="anchor" href="#normal-vector-interpolation">#</a>
</h3>
<p>This method aims at generating continuous normal vectors on a 2D surface to create an effect of depth and 2D lighting. Research projects such as Lumo<sup class="citation-ref">[1]</sup> have proposed to adopt this method to create shading for hand-drawn animation.</p>
<p>The algorithm starts with a Grease Pencil stroke, which can be seen as the contour of a 2D shape. Supposing the contour contains <span>
  \(C\)
</span>
 points, <span>
  \(\{(x_1, y_1), (x_2, y_2), ..., (x_C, y_C)\}\)
</span>
, it is easy to get their 2D normal vectors <span>
  \( \{(n_{1x}, n_{1y}), (n_{2x}, n_{2y}), ..., (n_{Cx}, n_{Cy})\} \)
</span>
. We then normalize them to the unit length and treat them as 3D vectors, assuming that the third dimension has zero value, i.e., assuming the vector is parallel to the 2D work plane.</p>
<div class="swiper normal-interpolation-fig">
    <div class="swiper-wrapper">
      
    <div class="swiper-slide"><figure>
        <figcaption>Calculated 2D normal vectors from stroke points.</figcaption>
        <img src="../alg_normal_1.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Add new vertices inside the stroke shape.</figcaption>
        <img src="../alg_normal_2.png">  
    </figure></div>
    <div class="swiper-slide"><figure>
        <figcaption>Each new vertex's normal vector is a weighted average of all contour normal vectors.</figcaption>
        <img src="../alg_normal_3.png">  
    </figure></div>

    </div>
    <div class="swiper-pagination"></div>
</div>


<script>
    var swiper = new Swiper(".normal-interpolation-fig", {
        pagination: {
        el: ".swiper-pagination",
        clickable: true,
        renderBullet: function (index, className) {
            return '<span class="' + className + '">' + (index + 1) + "</span>";
        },
        },
    });
</script>
<p>Then we create new vertices inside the shape. To calculate the normal vector of such an inside vertex, we take the weighted average of the normal vectors of all the contour points. The weight is the <strong>reciprocal squared distance</strong> from this new vertex to a contour point.</p>
<p><img src="../eq_normal_x.svg" alt="n_x = \frac{ \sum_{c=1}^{C} [(x-x_c)^2 &#43; (y-y_c)^2]^{-1} n_{cx}}{\sum_{c=1}^{C} [(x-x_c)^2 &#43; (y-y_c)^2]^{-1}}" /></p>
<p><img src="../eq_normal_y.svg" alt="n_y = \frac{ \sum_{c=1}^{C} [(x-x_c)^2 &#43; (y-y_c)^2]^{-1} n_{cy}}{\sum_{c=1}^{C} [(x-x_c)^2 &#43; (y-y_c)^2]^{-1}}" /></p>
<p>The equations above give us the first two components of the normal vector. By assuming the unit length, we can get the third component:</p>
<p><img src="../eq_normal_z.svg" alt="n_z = \sqrt{1 - {n_x}^2 - {n_y}^2}" /></p>
<p>This distance-based weighting and averaging can result in a smooth appearance. For example, a 2D circle will be shaded like a sphere.</p>
<h3 id="heightdepth-calculation">
  Height/Depth Calculation
  <a class="anchor" href="#heightdepth-calculation">#</a>
</h3>
<p>A normal map can be converted to height/depth values to get an actual 3D mesh. This add-on implements an <strong>inflation method</strong> by modifying a pixel-based algorithm<sup class="citation-ref">[2]</sup> to a vector-based one.</p>
<p>The method is based on the fact that the normal vector should always be perpendicular to the tangent vector. The tangent vector of a vertex <span>
  \(a\)
</span>
 can be calculated by subtracting its coordinates from those of another vertex <span>
  \(b \in \Gamma_{a}\)
</span>
 that shares an edge with it. In this way, an energy function can be defined by summing up the squared production of each pair of normal and tangent vectors, taking each edge in the mesh into account:</p>
<p><img src="../eq_depth_min_energy.svg" alt="E(z_1, z_2, ..., z_N) = \sum_{a=1}^N \sum_{b\in \Gamma_{a}} (\begin{bmatrix} n_{ax} &amp;amp; n_{ay} &amp;amp; n_{az} \end{bmatrix} \begin{bmatrix} x_a - x_b \ y_a - y_b \ z_a - z_b \end{bmatrix})^2 " /></p>
<p>The closer this energy is to zero, the more realistic the depth values are. Since the derivative of energy is linear, there is a wide range of optimizers available for this problem. The add-on adopts the L-BFGS-B algorithm provided by <a href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-lbfgsb.html">SciPy</a>.</p>
<p>Although not using its algorithm directly, the mesh generation module is also largely inspired by Monster Mash<sup class="citation-ref">[3]</sup>.</p>
<h3 id="2d-shading">
  2D Shading
  <a class="anchor" href="#2d-shading">#</a>
</h3>
<p>This add-on also supports calculating shadows and lights directly as vector polygons instead of generating 3D meshes. Similar concepts have also been discussed in some research papers. Unlike the research<sup class="citation-ref">[4]</sup> which proposes a novel formula to determine the shadow terminator, this add-on simply reuses the same method of normal interpolation combined with Boolean operations. However, my implementation benefits from certain techniques suggested by this research, such as sampling along the direction of the light.</p>
<blockquote class="citation-quote"><ol>
<li>Johnston, Scott F. &quot;Lumo: illumination for cel animation.&quot; In Proceedings of the 2nd international symposium on Non-photorealistic animation and rendering, pp. 45-ff. 2002.</li>
<li>Hudon, Matis, Sebastian Lutz, Rafael Pagés, and Aljosa Smolic. &quot;Augmenting hand-drawn art with global illumination effects through surface inflation.&quot; In Proceedings of the 16th ACM SIGGRAPH European Conference on Visual Media Production, pp. 1-9. 2019.</li>
<li>Dvorožňák, Marek, Daniel Sýkora, Cassidy Curtis, Brian Curless, Olga Sorkine-Hornung, and David Salesin. &quot;Monster mash: a single-view approach to casual 3D modeling and animation.&quot; ACM Transactions on Graphics (TOG) 39, no. 6 (2020): 1-12.</li>
<li>Hudon, Matis, Rafael Pagés, Mairéad Grogan, Jan Ondřej, and Aljoša Smolić. &quot;2D shading for cel animation.&quot; In Proceedings of the Joint Symposium on Computational Aesthetics and Sketch-Based Interfaces and Modeling and Non-Photorealistic Animation and Rendering, pp. 1-12. 2018.</li>
</ol>
</blockquote>
<h2 id="image-vectorization">
  Image Vectorization
  <a class="anchor" href="#image-vectorization">#</a>
</h2>
<p>The image vectorization operators (including line art extraction and color quantization) are mostly performed by directly calling functions of <a href="https://scipy.org/">SciPy</a> and <a href="https://scikit-image.org/">Scikit-Image</a> modules.</p>
<h3 id="line-art-extraction">
  Line Art Extraction
  <a class="anchor" href="#line-art-extraction">#</a>
</h3>
<p>The algorithm used for extracting lines from raster image pixels belongs to <strong>skeletonization</strong> or <strong>thinning</strong>. There have been several famous methods<sup class="citation-ref">[1,2]</sup> developed for this purpose. This add-on chooses <code>medial_axis</code> implemented in <a href="https://scikit-image.org/docs/stable/api/skimage.morphology.html#skimage.morphology.medial_axis">skimage.morphology</a>, since it calculates the distance from a pixel to the extracted skeleton, which is later converted to the radius of Grease Pencil stroke points.</p>
<h3 id="color-quantization">
  Color Quantization
  <a class="anchor" href="#color-quantization">#</a>
</h3>
<p>To vectorize a color image, the add-on uses the clustering algorithm to reduce the number of colors of the original image, so that pixels of each color can be treated one by one, just like a black-and-white image. The clustering algorithm in use is a very common one, K-means<sup class="citation-ref">[3]</sup>, treating each pixel's <code>rgb</code> values as a 3D vector.</p>
<p>After color reduction, the add-on converts each connected pixel regions to a contour by calling the function <code>find_contours</code> in <a href="https://scikit-image.org/docs/stable/api/skimage.measure.html#skimage.measure.find_contours">skimage.measure</a>, which uses the marching squares algorithm<sup class="citation-ref">[4]</sup>.</p>
<blockquote class="citation-quote"><ol>
<li>Skimage Skeletonize, <a href="https://scikit-image.org/docs/stable/auto_examples/edges/plot_skeleton.html">https://scikit-image.org/docs/stable/auto_examples/edges/plot_skeleton.html</a></li>
<li>Zhang, Tongjie Y., and Ching Y. Suen. &quot;A fast parallel algorithm for thinning digital patterns.&quot; Communications of the ACM 27, no. 3 (1984): 236-239.</li>
<li>K-means Clustering, <a href="https://en.wikipedia.org/wiki/K-means_clustering">https://en.wikipedia.org/wiki/K-means_clustering</a></li>
<li>Lorensen, William E., and Harvey E. Cline. &quot;Marching cubes: A high resolution 3D surface construction algorithm.&quot; In Seminal graphics: pioneering efforts that shaped the field, pp. 347-353. 1998.</li>
</ol>
</blockquote>
<h2 id="file-format-support">
  File Format Support
  <a class="anchor" href="#file-format-support">#</a>
</h2>
<p>The support of Adobe formats (writing <code>.psd</code> and reading <code>.abr</code>) follows the official specification<sup class="citation-ref">[1]</sup>. In addition, the parsing of brush files also refers to the description from <em>Just Solve the File Format Problem</em><sup class="citation-ref">[2]</sup> Wiki page and GIMP's source code<sup class="citation-ref">[3]</sup>.</p>
<p>The support of GIMP <code>.gbr</code> brushes follows the developer documentation<sup class="citation-ref">[4]</sup>.</p>
<p>A Procreate brush is an archive with image files and PLIST configurations. A Clip Studio Paint <code>.sut</code> brush is an SQLite database. Both formats can be parsed by the Python Standard Library.</p>
<blockquote class="citation-quote"><ol>
<li>Adobe Photoshop File Format Specification, <a href="https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/">https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/</a></li>
<li>Just Solve the File Format Problem, <a href="http://fileformats.archiveteam.org/wiki/Photoshop_brush">http://fileformats.archiveteam.org/wiki/Photoshop_brush</a></li>
<li><a href="https://github.com/GNOME/gimp/blob/master/app/core/gimpbrush-load.c">https://github.com/GNOME/gimp/blob/master/app/core/gimpbrush-load.c</a></li>
<li>The GIMP Paintbrush File Format, <a href="https://github.com/GNOME/gimp/blob/gimp-2-10/devel-docs/gbr.txt">https://github.com/GNOME/gimp/blob/gimp-2-10/devel-docs/gbr.txt</a></li>
</ol>
</blockquote>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#polygon-operations">Polygon Operations</a></li>
    <li><a href="#sketch-cleanup">Sketch Cleanup</a></li>
    <li><a href="#smart-fill">Smart Fill</a></li>
    <li><a href="#mesh-generation">Mesh Generation</a>
      <ul>
        <li><a href="#normal-vector-interpolation">Normal Vector Interpolation</a></li>
        <li><a href="#heightdepth-calculation">Height/Depth Calculation</a></li>
        <li><a href="#2d-shading">2D Shading</a></li>
      </ul>
    </li>
    <li><a href="#image-vectorization">Image Vectorization</a>
      <ul>
        <li><a href="#line-art-extraction">Line Art Extraction</a></li>
        <li><a href="#color-quantization">Color Quantization</a></li>
      </ul>
    </li>
    <li><a href="#file-format-support">File Format Support</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












